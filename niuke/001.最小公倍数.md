# 求最小公倍数

* 正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。

## 输入描述:

> 输入两个正整数A和B。

## 输出描述:

> 输出A和B的最小公倍数。

## 示例1

输入
> 5 7

输出
> 35


# 解题思路

第一次刷题就遇到一个数学基础的问题，发现所有的知识点都还给老师了，硬着头皮写了一个极low的代码，性能极差，决定补课。

先回忆一下小学的时候我们是怎么求最小公倍数的

```shell script
短除法求 12 和 8 的最小公倍数

2 | 12 8   # 从2到n尝试同时整除两个数
  +------
 2 | 6 4
   +-----
     3 2   # 尝试到3时停止
```

好的，上面就是基本做法，将数字质因数分解到不能同时求整数解为止，12和8的最小公倍数就是所有外围值的乘积(公约后得到的质因数的乘积)，即`24`。

计算机做质因数分解和人类做在方法上其实没有太大的区别，依靠穷举试探质因数，这也是为什么 rsa 非对称加密算法至今依然安全的原因，但是刷题这样设
计就明显不应该用这个思路了，实际上解题需要用到公倍数公约数的相关推论。

我比较喜欢的思路是由上面的解题过程推倒出来的推论，特别注意竖式左边的积为『最大公约数』

以第一次计算为例，做短除法的时候2个分母数是同时除以2的，所以是两数乘积÷4，但是我们只保留了一个2(这个行为叫公约)，所以实际上最小公倍数(所有
公约后质因数的乘积)=两数乘积÷最大公约数：

```shell script
最小公倍数 = 两数的乘积 / 最大公约数
```

那么怎么求最大公约数呢？

小学还学过另一个求最大公约数的办法`辗转相除法`：

```shell script
8 % 12 = 8
    12 % 8 = 4
         8 % 4 = 0
则 4 为最大公约数
```

是不是很神奇？说实话我早忘记了 T^T

这是典型的算法问题，可以通过循环或者递归的方式实现，下面核心代码来自百度百科：

```python
def gcd(n1, n2):
    """ 最大公约数 """
    return gcd(n2, n1 % n2) if n2 > 0 else n1
```

搞到最大公约数，下一步就很简单了

```python
def gcd(n1, n2):
    pass

def lcm(n1, n2):
    """ 最小公倍数 """
    return n1 * n2 // gcd(n1, n2)
```

做题的时候，python3的入参使用input()接收，所以答案可以写成如下:

```python
def gcd(n1, n2):
    """ 最大公约数 """
    return gcd(n2, n1 % n2) if n2 > 0 else n1


def lcm(n1, n2):
    """ 最小公倍数 """
    return n1 * n2 // gcd(n1, n2)


m, n = map(int, input().split())
print(lcm(m, n))
```
