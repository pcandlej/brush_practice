# 题目描述

* 计算一个数字的立方根，不使用库函数

## 详细描述：

* 接口说明

原型：

public static double getCubeRoot(double input)

输入:double 待求解参数

返回值:double  输入参数的立方根，保留一位小数


## 输入描述:
待求解参数 double类型

## 输出描述:
输入参数的立方根 也是double类型

## 示例1

输入
> 216

输出
> 6.0


# 解题思路

这道题是考察的应该是经典的夹逼思路，日常如果问到一个问题比如估计一下 30 的 3 次方根在哪个范围？

我们会想：3×3×3=27 < 30 < 3×3×4=36 << 4^3，那应该是 3 到 4 之间咯。

计算机也同理，利用二分法逐渐靠近想要的值，每次猜测的结果通过计算3次方来验证当前精度是否需要继续夹逼。

刚刚开始做的时候犯了一个错误，只对猜测值进行自身÷2或者×1.5的变更，那并不是有效的夹逼方式，极有可能出现死循环。

夹逼的过程实际上是对最大值和最小值的不断调整来实现的，举个例子

```text
求 27 的立方根

max  |  guess  | min | computing
27   | 13.5    | 0   | (27/2)^3 = 13.5^3 >> 13.5^2 太大了，底数的max一定小于 13.5
13.5 | 6.75    | 0   | (13.5/2)^3 = 6.75^3 >> 6^2 = 36 > 27 大了，max缩小到 6.75
6.75 | 3.375   | 0   | (6.75/2)^3 = 38.44
3.375| 1.6875  | 0   | (3.375/2)^3 ≈ 4.8 太小了，底数应该在 3.375 ~ 1.6875 之间
3.375| 2.53125 | 1.6875   | go on
```

有同学会问了，最后两行之间 guess 的差距就是 1.5 倍啊，那我们如果发现guess小了就×1.5不就可以了吗？

如果再往下计算就可以看到问题

```text
max  |  guess   | min     | computing
3.375| 2.53125  | 1.6875  | 16.2182922363 < 27
3.375| 2.953125 | 2.53125 | 正解
```

而 `2.53125 * 1.5 = 3.796875` 此时guess的1.5倍甚至超过了同期的max，其实这个时候 系数k ≈ 1.2857142857 ，是动态的，推导就很辛苦了，考试千万不要折磨自己

所以可以进行下面的编程:

```python
def dv(left, right, middle, target):
    power = pow(middle, 3)
    if round(power, 4) == round(target, 4):
        return round(middle, 1)
    elif power > target:
        return dv(left, middle, (middle + left) / 2, target)
    else:
        return dv(middle, right, (middle + right) / 2, target)


def getCubeRoot(input):
    return dv(0, input, input / 2, input)


if __name__ == '__main__':
    print(getCubeRoot(float(input())))
```
