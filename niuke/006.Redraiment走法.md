## 题目描述 
Redraiment是走梅花桩的高手。Redraiment总是起点不限，从前到后，往高的桩子走，但走的步数最多，不知道为什么？你能替Redraiment研究他最多走的步数吗？ 

样例输入

```markdown
6
2 5 1 5 4 5
```

样例输出

```markdown
3
```

提示

Example: 

> 6个点的高度各为 2 5 1 5 4 5 
> 
> 如从第1格开始走,最多为3步, 2 4 5 
> 
> 从第2格开始走,最多只有1步,5 
> 
> 而从第3格开始走最多有3步,1 4 5 
> 
> 从第5格开始走最多有2步,4 5
> 
> 所以这个结果是3。

接口说明

方法原型：

    int GetResult(int num, int[] pInput, List  pResult);

输入参数：

    int num：整数，表示数组元素的个数（保证有效）。
    int[] pInput: 数组，存放输入的数字。

输出参数：

    List pResult: 保证传入一个空的List，要求把结果放入第一个位置。
    
返回值：

    正确返回1，错误返回0

## 输入描述:

输入多行，先输入数组的个数，再输入相应个数的整数

## 输出描述:

输出结果

## 示例1
输入

```markdown
6
2 5 1 5 4 5
```

输出

```markdown
3
```


## 解题思路

这是最纠结的一题了，虽然注释的难度只是『中等』，但是属实难倒没有系统学习过算法知识的人。

本题是求最长上升子序列问题。一开始的想法是：遍历数字数组，逐个比对其后的子数组的最小值，若大于当前值，则入队并缩小子数组同时剔除子数组中相同的值。

但是这个时间复杂度是我们接受不了的，需要更简单思路。

学霸们提供了一个思路，值得借鉴。

从左到右，计算各个位置到达该数字的最大路径。假设右侧数字r比左侧数字l大，则到达r的最大路径就是到达l的最大路径+1。

```markdown
举例：若游标偏移到 4 时

7 3 6 4 8 1 9
      ^
易得 4 > 3 即 4 的最大路径(下面统一用函数 M(4) 表示到达 4 的最大路径)是 M(3)+1
而 M(3) 是之前的循环得到的，值为 1 ，所以到达 4 的最大路径是 1+1=2
而由于题目要求从前往后走，所以一旦计算出当前位置的最大路径就不会变更

同理，当游标偏移到 8 时

7 3 6 4 8 1 9
        ^
需要算到 8 > 7 即最大路径是 M(7)+1 = 1+1 = 2
     且 8 > 3 即最大路径是 M(3)+1 = 1+1 = 2
     且 8 > 6 即最大路径是 M(6)+1 = 1+1 = 2
     且 8 > 4 即最大路径是 M(4)+1 = 2+1 = 3
取最大，即 M(8)=3

当游标偏移到最后一个数字后，取 M(x) 最大的值输出即可
```

下面是这种思路的实现

```python
if __name__ == '__main__':
    while True:
        try:
            n = input()
            line = input().split()
            maxStep = [1]
            for i in range(1, len(line)):
                res = 1
                for j in range(0, i):
                    if int(line[j]) < int(line[i]):
                        res = max(maxStep[j] + 1, res)
                maxStep.append(res)
            print(max(maxStep))
        except:
            break
```
